---
title: JS的值类型和引用类型总结
date: 2019-03-19 21:49:47
tags:
---

## 前言

1.**JavaScript 的变量类型分为值类型和引用类型**

2.在 JS 中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象的值，这就是所说的**按引用访问**。

## JS 中的值类型

1.**占用空间固定，保存在栈中**:当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；栈中存储的基础变量以及一些对象的引用变量，基础变量的值是存储在栈中，而引用变量存储在栈中的是指向堆中的数组或者对象的地址，**这就是为何修改引用类型总会影响到其他指向这个地址的引用变量**;

2.保存与复制的是值本身;

3.使用 typeof 检测数据的类型;

4.基本类型数据是值类型。

## JS 中的引用类型

1.**占用空间不固定，保存在堆中**:当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用(因为对象的创建成本通常较大)，这个运行时数据区就是堆内存(**引用类型的值的大小会改变，所以不能把它放在栈中，否则会降低变量查询的速度，相反，放在变量的栈空间中的值是该对象存储在堆中的地址，地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响**)，堆内存中的对象不会随方法的结束而销毁，即便方法结束后，这个对象还可能被另一个引用变量所引用(方法的参数传递时很常见),则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它;

2.保存与复制的是指向对象的一个指针;

3.使用 instanceof 检测数据类型;

**如果变量是给定引用类型(根据它的原型链来识别)的实例，那么 instanceof 操作符就会返回 true**

```js
var a = [];
var b = {};
var c = /^$/;
console.log(a instanceof Array); // true
console.log(b instanceof Object); // true
console.log(c instanceof RegExp); // true
```

4.使用 new() 方法构造出的对象是引用型。

5.对于引用类型的值，我们可以添加属性和方法，也可以改变和删除其属性和方法。

## JS 中值类型和引用类型的区别

**主要有 4 点区别**

- 声明变量时不同的内存分配

- 不同的内存分配机制也带来不同的访问机制

- 复制变量时的不同

- 参数传递的不同(把实参复制给形参的过程)

**参数传递的不同**

1.值类型：只是把变量里的值传递给参数，之后参数和这个变量互不影响。

2.引用类型：对象变量，里面的值是这个对象在堆内存中的内存地址，因此它传递的值就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为他们都指向同一个对象。

**实例**:

```js
// 值类型保存与复制的是值本身，引用类型保存与复制的是指向对象的一个指针

var a = 100;
var b = a;

a = 200;

console.log(b); // 100

var a = { age: 20 };
var b = a;
b.age = 21;
console.log(a.age); // 21

// 值类型用typeof来区分

typeof undefined; // undefined
typeof "abc"; //string
typeof 123; // number
typeof true; // boolean

// 引用类型用typeof识别不出，需要用instanceof ,因为结果都会是object，除了函数会识别出function

typeof {}; // object
typeof []; // object
typeof null; // object
typeof console.log; // function

// 两者参数传递的例子
function setName(obj) {
  obj.name = "lalala";
  obj = new Object();
  obj.name = "hahha";
}
var person = new Object();
setName(person);
console.log(person.name);
// 上例证明了对象是按值传递的，如果person是按引用传递的，那么person就会自动被修改为指向其name属性值为“hahha”的新对象，但是当接下来再访问person.name时，显示的值仍然是"lalala"
```
